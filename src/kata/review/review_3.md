# Q&A
> * https://javastudy.ru/interview/exceptions/
> * http://topuch.com/kniga-uorberton-funkcionalenoe-programmirovanie-v-massi-java8/index3.html
> * https://javarush.com/groups/posts/4062-kofe-breyk-203-kak-obrabatihvatjh-iskljuchenija-s-pomojshjhju-operatora-try-with-resource
> * https://programming.guide/java/try-finally.html
> * https://www.youtube.com/watch?v=mLpMtc62530

# Ревью №3

* [Что такое исключение? Для чего они нужны?](#1)
* [Зачем исключение в java представлены в качестве классов?](#2)
* [Расскажи про иерархию исключений?](#3)
* [В чём разница между проверяемыми исключениями и не проверяемыми? В чём разница с точки зрения синтаксиса и идеологическая при использовании?](#4)
* [Можно ли обработать непроверяемое исключение?](#5)
* [Нужно ли ловить Error исключения? ](#6)
* [Как бросить исключение? Можно ли бросить НЕ новое исключение?](#7)
* [Расскажи про информацию, которая находится внутри исключения? Как с ней работать?](#8)
* [Что такое подавленные исключения? Как достать подавленное исключение?](#9)
* [Какую информацию можно получить из StackTraceElement?](#10)
* [Расскажи про конструкцию try-catch-finally?](#11)
* [Что такое try-with-resources? Как работает эта конструкция?](#12)
* [Расскажи, как правильно ловить исключения? Иерархия catch блоков](#13)
* [Можно ли одном catch обработать несколько исключений?](#14)

---
Дополнительные вопросы

* [Как сделать свое проверяемое исключение? А не проверяемое ?](#15)
* [Зачем мне может понадобиться создавать свой собственный тип исключения?](#16)
* [Что делает ключевое слово throws](#17)
* [Методы класса Throwable](#18)
* [Может ли main выбрасывать исключения, что будет происходить?](#19)
* [Что будет если при закрытии ресурса вылетит исключение в конструкции try-with-resources?](#20)
* [Можно ли в одном блоке try открыть сразу несколько ресурсов?](#21)
* [Что случится, если в блоке catch произойдет исключение? Можно ли внутри блока catch написать ещё одну конструкцию с вложенным try? А можно ли написать полноценный try-catch-finally?](#22)
* [Что если исключение вылетело сначала в try, а потом в close в конструкции try-with-recources? Какое исключение вылетит? Что будет с другим?](#23)
* [Что если в конструкции try finally вылетело исключение сначала в try а потом в finally? Какое исключение вылетит? Что будет с другим?](#24)
* [Что такое логирование? Для чего оно нужно? Почему нельзя просто использовать sout?](#25)
* [Какие есть уровни логирования? За что отвечает каждый из этих уровней?](#26)
* [Обязательно ли передавать в метод getLogger() имя класса? Почему так принято?](#27)

---
* [Когда не будет выполнен finally(4 случая)?](#28)
* [Чем отличается close от autoclosable?](#29)

---

> <h3 id="3"> Что такое исключение? Для чего они нужны? </h3>
Что такое исключения (exceptions java)

Исключения в программировании (exceptions) — это механизм, который **позволяет программе обрабатывать нетипичную ситуацию и при этом не прекращать работу**. Благодаря этому механизму разработчик может описать в коде реакцию программы на такие ситуации.

Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

> <h3 id="2"> Зачем исключение в java представлены в качестве классов? </h3>

Исключения в Java представлены в качестве классов, чтобы обеспечить процесс исключений более удобным и эффективным. Классы исключений позволяют пользователям создавать свои собственные исключения, хранить дополнительную информацию об исключительных ситуациях, а также реализовывать различные методы, такие как stack trace, для лучшего понимания и управления исключениями.

> <h3 id="3"> Расскажи про иерархию исключений? </h3>
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.

Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.

> <h3 id="4"> В чём разница между проверяемыми исключениями и не проверяемыми? В чём разница с точки зрения синтаксиса и идеологическая при использовании? </h3>

В Java все исключения делятся на два типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).

Checked исключения отличаются от Unchecked исключения в Java, тем что:

1) Наличие\обработка Checked исключения проверяются на этапе компиляции.

2) Наличие\обработка Unchecked исключения происходит на этапе выполнения.

Проверяемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException). Нельзя скомпилировать и запустить программу, если в ней есть проверяемое исключение, которое кинули, но не обработали и не пробросили.

Обработать – с помощью блока try-catch.

Пробросить – с помощью throws в сигнатуре метода.

Если исключение может быть правильно обработано, его надо ловить, иначе, оно должно быть проброшено дальше.

Unchecked исключения не нужно обрабатывать блоком catch, поскольку эти проблемы связанны чаще всего с JVM (мы не сможем дать JVM больше памяти программой).

---

Checked — вид исключений, которые нужно всегда обрабатывать посредством использования механизма — try — catch или пробрасывать в методы выше.

Throws используется в заголовке метода для обозначения возможных брошенных исключений данным методом. То есть это и есть механизм “проброски” исключений в методы выше.

Unchecked — вид исключений, которые не нужно обрабатывать, они, как правило, менее предсказуемы и менее вероятны. Тем не менее, по желанию их тоже можно обработать.

Throw используется, при ручном броске исключения, например:
```java
throw new Exception();
```
---

список неконтролируемых исключений на этапе выполнения (Unchecked RuntimeException)

1	java.lang.ArithmeticException
Арифметическая ошибка, например, деление на ноль.

2	java.lang.ArrayIndexOutOfBoundsException
Индекс массива выходит за пределы.

3	java.lang.ArrayStoreException
Присвоение элементу массива несовместимого типа.

4	java.lang.ClassCastException
Недопустимое приведение типов.

5	java.lang.IllegalArgumentException
Недопустимый аргумент, используемый для вызова метода.

6	java.lang.IllegalMonitorStateException
Недопустимая работа монитора, например, ожидание разблокированного потока.

7	java.lang.IllegalStateException
Окружающая обстановка или приложение находится в неправильном состоянии.

8	java.lang.IllegalThreadStateException
Запрошенная операция несовместима с текущим состоянием потока.

9	java.lang.IndexOutOfBoundsException
Некоторый тип индекса находится за пределом.

10	java.lang.NegativeArraySizeException
Массив создан с отрицательным размером.

11	java.lang.NullPointerException
Недопустимое использование нулевой ссылки.

12	java.lang.NumberFormatException
Неверное преобразование строки в числовой формат.

13	java.lang.SecurityException
Попытка нарушить безопасность.

14	java.lang.StringIndexOutOfBounds
Попытка индексирования за пределами строки.

15	java.lang.UnsupportedOperationException
Была обнаружена неподдерживаемая операция.

список контролируемых исключений (Checked Exceptions) в Java, определенных в java.lang.

1	java.lang.ClassNotFoundException
Класс не найден.

2	java.lang.CloneNotSupportedException
Попытка клонировать объект, который не реализует Cloneable интерфейс.

3	java.lang.IllegalAccessException
Запрещен доступ к классу.

4	java.lang.InstantiationException
Попытка создать объект абстрактного класса или интерфейса.

5	java.lang.InterruptedException
Один поток был прерван другим потоком.

6	java.lang.NoSuchFieldException
Запрошенное поле не существует.

7	java.lang.NoSuchMethodException
Запрошенный метод не существует.

### _Методы исключений_

Далее представлен список важных методов, доступных в классе Throwable.

* public String getMessage()
  + Возврат подробного сообщения о произошедшем исключении. Инициализация данного сообщения производится в конструкторе Throwable.
* public Throwable getCause()
  + Возврат причины исключения, представленной объектом Throwable.
* public String toString()
  + Возврат имени класса, соединенного с результатом getMessage().
* public void printStackTrace()
  + Выведение результата toString() совместно с трассировкой стека в System.err, поток вывода ошибок.
* public StackTraceElement [] getStackTrace()
  + Возврат массива, содержащего каждый элемент в трассировке стека. Элемент с номером 0 представляет вершину стека вызовов, последний элемент массива отображает метод на дне стека вызовов.
* public Throwable fillInStackTrace()
  + Заполняет трассировку стека данного объекта Throwable текущей трассировкой стека, дополняя какую-либо предшествующую информацию в трассировке стека.


> <h3 id="5"> Можно ли обработать непроверяемое исключение? </h3>
Да можно, но это необязательно. С не-проверяемыми исключениями программа просто прекратит работу, если одно из них произойдет.

Unchecked исключения можно пробрасывать с помощью throws и обрабатывать с помощью try-catch.

> <h3 id="6"> Нужно ли ловить Error исключения?  </h3>

Технически, Error, как и любой другой Throwable можно поймать в блок catch . Такой код абсолютно валидный и скомпилируется без проблем. На практике, согласно спецификации, значение исключения типа Error – unchecked ошибка, ловить которую нет смысла.

> <h3 id="7"> Как бросить исключение? Можно ли бросить НЕ новое исключение?  </h3>

Бросить исключение можно с помощью throw ключевого слова.

С помощью ключевого слова throws в объявлении метода можно передать исключение выше, в метод, который вызывает этот метод. И обрабатывать его уже там. Естественно, там можно бросить НЕ новое исключение.

> <h3 id="8"> Расскажи про информацию, которая находится внутри исключения? Как с ней работать?  </h3>

Пример исключения:

Exception in thread "main" java.io.FileNotFoundException: C:\Users\Username\Desktop\test.txt (Системе не удается найти указанный путь)

Разберем по словам:

Exception in thread "main" – то, в каком методе было выброшено исключение.

java.io.FileNotFoundException – класс исключения.

: C:\Users\Username\Desktop\test.txt – причина исключения

(Системе не удается найти указанный путь) – краткое объяснение причины исключения.

С каждым исключением нужно работать по разному, однако из этой информации можно понять где возникает исключение, и где его нужно обработать. Так же можно сделать вывод по поводу класса исключения, и понять, в чем именно проблема.

> <h3 id="9"> Что такое подавленные исключения? Как достать подавленное исключение?</h3>

Подавленное исключение-это исключение, которое выбрасывается, но каким-то образом игнорируется. Распространенный сценарий для этого в Java-это когда блок *finally* создает исключение. Любое исключение, первоначально возникшее в блоке *try*, затем подавляется.

Мы можем использовать два метода в классе Throwable
 для обработки подавленных исключений: *addSuppressed* и *getSuppressed*.

*addSuppressed – добавляет в stack trace данные о подавленном исключении.*

*getSuppressed – возвращает массив подавленных исключений, которые были подавленны перед выбросом этого исключения.*

> <h3 id="10">Какую информацию можно получить из StackTraceElement?</h3>

Каждый элемент StackTrace представляет один метод в стеке. Все элементы стека, кроме того, что находится наверху стека, представляют собой вызов метода. Элемент в верхней части стека представляет собой точку выполнения, в которой была сгенерирована трассировка стека. Как правило, это точка, в которой был создан объект throwable(выброшено исключение), соответствующий трассировке стека.

Из стека можно понять порядок методов, которые вызывали друг друга, до появления ошибки.
```java
public class Test {
    public static void main(String[] args) {
        method1();
        method2();
    }
    public static void method1() {
        //не вызывает ничего
    }
    public static void method2() {
        method3();
        method4();
    }
    public static void method3() {
        //не вызывает ничего
    }
    public static void method4() {
        method5();
    }
    public static void method5() {
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element:stackTraceElements) {
            System.out.println(element.getMethodName());
        }
    }
}
```
```
getStackTrace
method5
method4
method2
main
```
>> Thread.currentThread() - получение ссылки на текущий поток, в котором выполняются методы, которые мы хотим отследить
> 
>> getStackTrace() - получаем весь Стэк вызываемых методов(Это обычный геттер для StackTrace)

Вот что еще мы можем получить из StackTraceElement:

* String getClassName() - Возвращает имя класса.
* String getMethodName() - Возвращает имя метода.
* String getFileName() - Возвращает имя файла (в одном файле может быть много классов).
* String getModuleName() - Возвращает имя модуля (может быть null).
* String getModuleVersion() - Возвращает версию модуля (может быть null).
* int getLineNumber() - Возвращает номер строки в файле, в которой был вызов метода.
  
> <h3 id="11">Расскажи про конструкцию try-catch-finally?</h3>

**Обработка исключений в Java основана на использовании в программе следующих ключевых слов:**

- **try** – определяет блок кода, в котором может произойти исключение;
- **catch** – определяет блок кода, в котором происходит обработка исключения;
- **finally** – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока try.

> <h3 id="12">Что такое try-with-resources? Как работает эта конструкция?</h3>

Оператор try-with-resources — это try оператор, объявляющий один или несколько ресурсов. 
Ресурс — это объект, который должен быть закрыт после того, как программа закончит работу с ним. 
Оператор try-with-resources гарантирует, что каждый ресурс будет закрыт в конце оператора.

Интерфейс AutoCloseable

Любой объект, который реализует java.lang.AutoCloseable, включая все объекты, которые реализуют java.io.Closeable, может использоваться как ресурс.

> <h3 id="13">Расскажи, как правильно ловить исключения? Иерархия catch блоков</h3>

Иерархия catch блоков должна быть от самых sub-throwable к самым super-throwable.

Если мы хотим отловить несколько конкретных исключений, они должны стоять выше в иерархии catch блоков, чем общий или default catch блок, иначе их просто перекроет catch, с более широким списком подходящих exception, и выполнит свою работу.

В итоге надо идти от более низкоуровневых exception к более высокоуровневым, спускаясь вниз по коду:)

> <h3 id="14">Можно ли одном catch обработать несколько исключений?</h3>

В Java 7 и более новых версиях языка предусмотрена возможность перехватить несколько исключений одновременно в одном блоке catch. Для этого нужно перечислить типы исключений через вертикальную черту (|). Вот как выглядит пример кода с такой конструкцией:

```java
try {
    ...
} catch (ExceptionType1 | ExceptionType2 | ExceptionType3 e) {
    handleException(e);
}
```
Такой способ перехвата исключений называется множественным перехватом исключений или multi-catch. Это удобный способ обработки нескольких исключений, когда для всех из них применяется одна и та же логика обработки.

В одном блоке catch нельзя добавить допустим runTimeException и его наследника. 

---

## _Дополнительные вопросы_

> <h3 id="15">Как сделать свое проверяемое исключение? А не проверяемое ?</h3>

Что бы создать свой собственный класс с непроверяемым исключением, нужно сделать его наследником Error или класса RuntimeException.

Соответственно если он будет наследником любого другого класса проверяемого исключения, ваш класс будет проверяемым исключением.

> <h3 id="16">Зачем мне может понадобиться создавать свой собственный тип исключения?</h3>

Вы можете создавать свои собственные типы исключений для управления ошибками, которые могут возникнуть в процессе выполнения программы. Это может быть полезно, если вы хотите иметь более точное понимание того, что произошло, и управлять исключениями более эффективно.

Пользовательские исключения предоставляют вам гибкость при добавлении полей и методов, которые не являются частью стандартного класса исключений Java. Они могут хранить дополнительную информацию, например код ошибки, относящийся к конкретному приложению, или предоставлять служебные методы, которые можно использовать для обработки исключения или представления его пользователю.

> <h3 id="17">Что делает ключевое слово throws</h3>

Ключевое слово throws **используется, чтобы в сигнатуре метода указать, что он выбрасывает исключение**. Его можно использовать, чтобы передавать исключения по стеку вызовов и указать, что эти исключения не обязательно должны обрабатываться в методе, в котором они объявлены.

Применяется для всех типов исключений.

> <h3 id="18">Методы класса Throwable</h3>

1. getMessage() - возвращает сообщение об исключении.
2. getLocalizedMessage() - возвращает локализованное сообщение об исключении.
3. getCause() - возвращает причину исключения.
4. printStackTrace() - выводит стек вызовов строкой.
5. fillInStackTrace() - создает новое исключение с новым стеком вызовов, связанным с текущим местом исключения.
6. getStackTrace() - получает массив трассировки стека, связанный с исключением.
7. setStackTrace() - устанавливает массив трассировки стека, связанный с исключением.
8. initCause() - инициализирует причину, связанную с исключением.

> <h3 id="19">Может ли main выбрасывать исключения, что будет происходить?</h3>

Может. main выбросит исключение и завершит работу.

> <h3 id="20">Что будет если при закрытии ресурса вылетит исключение в конструкции try-with-resources?</h3>

Ресурс не будет закрыт. Программа аварийно завершится.

> <h3 id="21">Можно ли в одном блоке try открыть сразу несколько ресурсов?</h3>

Открыть можно сколько угодно ресурсов. Ресурсы перечисляются через точку с запятой.

> <h3 id="22">Что случится, если в блоке catch произойдет исключение? Можно ли внутри блока catch написать ещё одну конструкцию с вложенным try? А можно ли написать полноценный try-catch-finally?</h3>

Внутри catch блока можно разместить try с ресурсами.

Внутри catch блока можно разместить try-catch-finally.

> <h3 id="23">Что если исключение вылетело сначала в try, а потом в close в конструкции try-with-recources? Какое исключение вылетит? Что будет с другим?</h3>

Исключение из close можно будет словить имея на руках исключение из Try.

Исключение из close будет добавленно в supressed.

> <h3 id="24">Что если в конструкции try finally вылетело исключение сначала в try а потом в finally? Какое исключение вылетит? Что будет с другим?</h3>

Исключение из Try будет полностью затерто.

> <h3 id="25">Что такое логирование? Для чего оно нужно? Почему нельзя просто использовать sout?</h3>

Логирование Java — это **процесс, при котором программа на Java-языке записывает сведения о своем исполнении в некий файл или базу данных**. Логирование дает возможность отслеживать ход исполнения программы и конкретно кода.

Если уйти с работы, и оставить программу работать, при ошибке, информация в логах сохранится, а в sout нет.

В каждом логере видны только ошибки, уровнем ниже или равные уровню самого логера.

Т.е в логере с уровнем INFO будут видны ошибки SEVERE, WARNING, INFO.

> <h3 id="26">Какие есть уровни логирования? За что отвечает каждый из этих уровней?</h3>

Каждое сообщение журнала имеет связанный объект уровня журнала. Уровень дает приблизительное представление о важности и срочности сообщений журнала. Объекты уровня журнала инкапсулируют целочисленное значение, причем более высокие значения указывают на более высокие приоритеты.

Класс Level определяет семь стандартных уровней журнала: от FINEST (самый низкий приоритет, с самым низким значением) до SEVERE (самый высокий приоритет, с самым высоким значением).

1. SEVERE (ошибка-ужас-ужас) - юбая ошибка / исключение, которое является или может быть критическим
2. WARNING (предупреждение) - любое сообщение, которое может предупредить нас о потенциальных проблемах, например когда пользователь пытался войти в систему с неправильными учетными данными - что может указывать на атаку, если это происходит часто или в короткие периоды времени
3. INFO (информационное сообщение) – о нормальном ходе исполнения программы
4. CONFIG – логгирование конфигурационных параметров
5. FINE – совсем детальное логгирование о действиях программы
6. FINER – совсем детальное логгирование о действиях программы
7. FINEST – совсем детальное логгирование о действиях программы

В логгере есть ещё Форматтер (Formatter), Хэндлер (Handler), setLevel.

Метод log() или все методы с названием уровней логгирования: (метод warning(), info(), config() и т.д.), getLogger();

Логгирование позволяет ответить на вопросы, что происходило, когда и при каких обстоятельствах. Без логов сложно понять, из-за чего появляется ошибка, если она возникает периодически и только при определенных условиях


> <h3 id="27">Обязательно ли передавать в метод getLogger() имя класса? Почему так принято?</h3>

***Имя класса*** специально передается для того, чтобы знать, откуда идет логирование.

В качестве имени логера я используют имя класса, на самом деле это не единственный способ, можно пытаться организовать какую-то свою иерархию логирования (например transport layer/app layer для подсистем имеющих дело с обменом данными), но как показывает практика выдумывать и главное потом неукоснительно следовать такой иерархии крайне сложно, а вариант с именами логеров совпадающими с именами классов весьма хорош и используется в 99% проектов

> <h3 id="28">Когда не будет выполнен finally(4 случая)?</h3>

* Если упала JVM
* Бесконеччный цикл в JVM (в блоке try/catch).
* Была вызвана команда System.exit,
* Если это поток демон, все не-демон потоки завершились, то он завершится до finally

> <h3 id="29">Чем отличается close от autoclosable?</h3>

в autoclosable не throws IOException, а расширен до Exception.